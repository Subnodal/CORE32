start:
    test1
    test2
    test3
    test4
    test5
    test6
    test7
    test8
    test9
    ret

+io.casm
+./imported.casm

#OUTB: {'o' int'}

outputHexDigit: ( nibble' -- )
    dup' 9' >' $.letter if
    '0' +' #OUTB ret

    .letter:
        'A' 10' -' +' #OUTB ret

outputHexByte: ( byte' -- )
    dup' 4' >>' outputHexDigit
    0b1111' &' outputHexDigit
    ret

outputHexLongPart: ( long -- )
    '0' #OUTB
    'x' #OUTB
    outputHexByte
    outputHexByte
    outputHexByte
    outputHexByte
    ret

outputHexLong: ( long -- )
    outputHexLongPart
    '\n' #OUTB
    ret

outputDecPart: ( value -- )
    ${.i: [0] .minI: [0] .value: [0] .buffer: [~8 0']}

    $.value set

    7 $.i set
    7 $.minI set

    .loop:
        {{$.value get' 10' %'} '0' +'} {$.i get $.buffer +} set'
        $.i get -- $.i set
        $.value get 10 / $.value set
        $.value get 0 != ?{$.i get $.minI set}
        $.i get 0 != $.loop if

    $.minI get $.buffer + print
    ret

outputDec: ( value -- )
    outputDecPart
    '\n' #OUTB
    ret

outputFloat: ( value% -- )
    dup% from% to dup outputDecPart
    
    from to% -%
    
    dup% 0% =% $.end if

    '.' #OUTB

    .loop:
        10% *% dup% from% to dup outputDecPart

        from to% -%

        dup% 0% !=% $.loop if

    .end:
        '\n' #OUTB

        drop% ret

test1: ( Simple count-controlled loop )
    'A' #OUTB ( Print A )

    10 ( Loop 10 times )

    .loop:
        'B' #OUTB ( Print B )
        -- ( Decrement loop counter )
        dup 0 > $.loop if ( Loop if not zero )

    '\n' #OUTB ( Print newline )

    ret

test2: ( Outputting hex )
    0xA1B2C3D4 outputHexLong
    '\n' #OUTB
    ret

test3: ( Fibonacci sequence )
    ${.a: [0] .b: [1]}

    10

    .loop:
        {$.a get} {$.b get} +
        dup outputHexLong
        $.b get $.a set
        $.b set

        --
        dup 0 > $.loop if

    ret

test4: ( Groups )
    {'A' #OUTB}
    {0' ?{'B' #OUTB}}
    {1' ?{'C' #OUTB}}
    :{0x44' #OUTB ret}
    ${0x45' #OUTB}
    call

    '\n' #OUTB

    ret

testString: ["Test string!\n" 0]

test5: ( Strings )
    "Hello, world!\n" print
    "This is a test!\n" print
    $testString print

    imported_output

    ret

Person:
    .name: [0]
    .age: [0]
    .team: [0']

printPerson: ( $person -- )
    dup #Person.name + get print
    " is " print
    dup #Person.age + get outputDecPart
    " years old and is on team " print
    #Person.team + get' #OUTB
    '\n' #OUTB
    ret

test6: ( Objects )
    ${.alice: ~Person .bob: ~Person}

    Person~ outputHexLong
    Person.name~ outputHexLong
    Person.age~ outputHexLong
    Person.team~ outputHexLong

    "Alice" $.alice #Person.name + set
    20 $.alice #Person.age + set
    'X' $.alice #Person.team + set'

    "Bob" $.bob #Person.name + set
    42 $.bob #Person.age + set
    'O' $.bob #Person.team + set'

    $.alice printPerson
    $.bob printPerson

    ret

#MACRO_A: 0x1234
#MACRO_B: 0x5678
#MACRO_C: {2 * outputDec}

test7: ( Macros )
    #MACRO_A outputHexLong
    #MACRO_B outputHexLong

    5 #MACRO_C
    10 #MACRO_C

    ret

handler: ( * callId -- * )
    dup [put "calA"] = ?{
        "Call A!\n" print
        drop ret
    }

    dup [put "calB"] = ?{
        "Call B!\n" print
        drop ret
    }

    "Invalid system call\n" print

    drop ret

#CALL_A: {[put "calA"] int}
#CALL_B: {[put "calB"] int}

test8: ( System calls )
    "Test!\n" print
    $handler 'R' int'

    #CALL_A
    #CALL_B

    ret

test9: ( Floating-point )
    "10 / 7 = " print
    10% 7% /% outputFloat

    "10 / 0 = " print
    10% 0% /% outputFloat

    "10 % 0 = " print
    10% 0% %% outputFloat

    ret