#_MEM_ALIGN_SIZE: 4
#_MEM_FLAG_USED: 0x80000000

_mem_heapBase: [0]
_mem_firstFreeBlock: [0]
_mem_debugger: [$_mem_defaultDebugger]

_mem_Block: [0]

_mem_align: ( $unaligned -> $aligned )
    #_MEM_ALIGN_SIZE + 1 - #_MEM_ALIGN_SIZE 1 - 0xFFFFFFFF ^ & ret

_mem_blockIsUsed: ( $addr -> isUsed' )
    get #_MEM_FLAG_USED & 0 != ret

_mem_blockSize: ( $addr -> size )
    get {#_MEM_FLAG_USED 1 -} & ret

_mem_blockIsLast: ( $addr -> isLast' )
    get 0 = ret

_mem_defaultDebugger: ( $message -> )
    drop ret

_mem_debug: ( $message -> )
    $_mem_debugger get call ret

mem_init: ( -> )
    $_mem_heapBase get 0 = ?{
        ( Get heap base from code end interrupt if not explicitly set )
        'e' int' _mem_align $_mem_heapBase set
    }

    $_mem_firstFreeBlock get 0 = ?{
        $_mem_heapBase get $_mem_firstFreeBlock set
    }

    ret

mem_new: ( size -> $addr )
    ${.size: [0] .currentBlock: [0]}

    "> new\n" _mem_debug

    mem_init

    $_mem_firstFreeBlock get 0 = ?{drop 0 ret}

    _mem_align $.size set
    $_mem_firstFreeBlock get $.currentBlock set

    $.size get 0 = ?{#_MEM_ALIGN_SIZE $.size set}
    $.size get #_MEM_FLAG_USED & 0 != ?{0 ret}

    .blockSearchLoop:
        $.currentBlock get _mem_blockIsLast ?{
            "Use last block\n" _mem_debug

            {$.size get #_MEM_FLAG_USED |} {$.currentBlock get} set
            0 {{$.currentBlock get} _mem_Block~ + {$.size get} +} set ( Create a new last block after this one )

            $.currentBlock get $_mem_firstFreeBlock get = ?{
                "  Set next free block\n" _mem_debug

                {{$.currentBlock get} _mem_Block~ + {$.size get} +} $_mem_firstFreeBlock set
            }

            {{$.currentBlock get} _mem_Block~ +} ret
        }

        ${.originalBlockSize: [0]}
        {$.currentBlock get _mem_blockSize +} $.originalBlockSize set

        $.currentBlock get _mem_blockIsUsed ?{
            "Skip used\n" _mem_debug

            {{$.currentBlock get} _mem_Block~ + {$.originalBlockSize get} +} $.currentBlock set

            $.blockSearchLoop jump
        }

        {$.originalBlockSize get} {$.size get} < ?{
            ${.originalBlock: [0] .totalUsableSize: [0] .encounteredLastBlock: [0']}
            $.currentBlock get $.originalBlock set
            $.originalBlockSize get $.totalUsableSize set
            0' $.encounteredLastBlock set'

            "Attempt merge\n" _mem_debug

            .blockMergeLoop:
                $.currentBlock get _mem_Block~ {$.currentBlock get _mem_blockSize} + + $.currentBlock set

                $.currentBlock get _mem_blockIsUsed ?{
                    "  Encountered used block\n" _mem_debug

                    $.finishBlockMerge jump
                }

                $.currentBlock get _mem_blockIsLast ?{
                    "  Encountered last block\n" _mem_debug

                    1' $.encounteredLastBlock set'

                    $.finishBlockMerge jump
                }

                {{$.totalUsableSize get} {$.currentBlock get get} + _mem_Block~ +} $.totalUsableSize set

                $.blockMergeLoop jump

            .finishBlockMerge:

            $.encounteredLastBlock get' dup' ?{
                "  Using last block\n" _mem_debug

                $.originalBlock get $.currentBlock set
                $.totalUsableSize get $.originalBlockSize set

                0 {{$.currentBlock get} _mem_Block~ + {$.size get} +} set ( Create a new last block after this one )
                {$.size get} {$.currentBlock get} set ( Set this block's size )
            } !' ?{
                $.totalUsableSize get {$.originalBlock get} set

                {$.totalUsableSize get} {$.size get _mem_Block~ +} < ?{
                    $.blockSearchLoop jump
                }

                "  Use merged block\n" _mem_debug

                $.originalBlock get $.currentBlock set
                $.totalUsableSize get $.originalBlockSize set
            }
        }

        {$.originalBlockSize get} {$.size get _mem_Block~ + #_MEM_ALIGN_SIZE +} > ?{
            ( Split this block so that the rest can be used for other purposes )

            "Split block\n" _mem_debug

            $.size get {$.currentBlock get} set
            {{$.originalBlockSize get} {$.size get} - _mem_Block~ -} {{$.currentBlock get} _mem_Block~ + {$.size get} +} set
        }

        "Mark as used\n" _mem_debug

        {$.currentBlock get get} #_MEM_FLAG_USED | {$.currentBlock get} set

        $.currentBlock get $_mem_firstFreeBlock = ?{
            "Search for a new first free block\n" _mem_debug

            .findNewFirstFreeBlockLoop:
                $_mem_firstFreeBlock _mem_blockIsUsed ?{
                    $.foundNewFirstFreeBlock jump
                }

                {{$_mem_firstFreeBlock get} {$_mem_firstFreeBlock get _mem_blockSize} +} _mem_Block + $_mem_firstFreeBlock set

                $.findNewFirstFreeBlockLoop jump

            .foundNewFirstFreeBlock:
        }

        $.currentBlock get _mem_Block~ + ret

mem_free: ( $addrPtr -> )
    ${.block: [0]}

    "> free\n" _mem_debug
    
    mem_init

    dup get ( Get referenced address from address pointer )
    over 0 swap set ( Make address pointer's value null )
    swap drop ( Drop address pointer itself )

    $_mem_firstFreeBlock get 0 = ?{ret}
    dup 0 = ?{drop ret}

    _mem_Block~ - $.block set

    {$.block get get} {#_MEM_FLAG_USED 0xFFFFFFFF ^} & {$.block get} set

    {$.block get} {$_mem_firstFreeBlock get} < ?{
        "Set first free block\n" _mem_debug

        {$.block get} $_mem_firstFreeBlock set
    }

    ${.currentBlock: [0]}
    {{$.block get} _mem_Block~ + {$.block get get} +} $.currentBlock set

    ( Merge together any subsequent free blocks )
    .blockMergeLoop:
        $.currentBlock get _mem_blockIsUsed ?{ret}

        $.currentBlock get _mem_blockIsLast ?{
            "Convert to last block\n" _mem_debug

            0 {$.block get} set ( Make the penultimate block the last one instead )

            ret
        }

        "Merge subsequent block\n" _mem_debug

        {{$.block get get} {$.currentBlock get _mem_blockSize} + _mem_Block~ +} {$.block get} set
        {{$.currentBlock get} {$.currentBlock get _mem_blockSize} + _mem_Block~ +} $.currentBlock set

        $.blockMergeLoop jump

mem_resize: ( size $addrPtr -> success' )
    ${.addrPtr: [0] .block: [0] .size: [0]}

    "> resize\n" _mem_debug

    mem_init

    $_mem_firstFreeBlock get 0 = ?{drop drop 0 ret}

    swap _mem_align $.size set

    dup get 0 = ?{
        {$.size get} mem_new
        0 = ?{drop 0' ret}
        swap get set
        1' ret
    }

    dup $.addrPtr set
    get _mem_Block~ - $.block set

    $.size get 0 = ?{#_MEM_ALIGN_SIZE $.size set}
    $.size get #_MEM_FLAG_USED & 0 != ?{0 ret}

    {$.size get} {$.block get _mem_blockSize} = ?{
        "Equal size\n" _mem_debug
        1' ret
    }

    {$.block get} _mem_Block~ + {$.block get _mem_blockSize} + _mem_blockIsLast ?{
        ( Modify last block to match new size )

        "Modify last block\n" _mem_debug

        {{$.block get} _mem_Block~ + {$.block get _mem_blockSize} +} {$_mem_firstFreeBlock get} = ?{
            ( Push pointer to first free block further down if it currently lies in the extended space )

            "  Increase first free block\n" _mem_debug

            {$.block get} _mem_Block~ + {$.size get} + $_mem_firstFreeBlock set
        }

        {$.size get #_MEM_FLAG_USED |} {$.block get} set
        0 {{$.block get} _mem_Block~ + {$.size get} +} set

        1' ret
    }

    {$.size get _mem_Block~ +} {$.block get _mem_blockSize} < ?{
        ( Truncate current block by splitting truncated portion off into new block )

        "Truncate block\n" _mem_debug

        {{$.block get _mem_blockSize} {$.size get} - _mem_Block~ -} {{$.block get} _mem_Block~ + {$.size get} +} set   
        {$.size get #_MEM_FLAG_USED |} {$.block get} set

        1' ret
    }

    ( Perform full reallocation )

    "Fully reallocate\n" _mem_debug

    $.size get mem_new

    dup 0 = ?{drop 0' ret}

    ${.newAddr: [0] .oldAddrPtr: [0]}
    $.newAddr set
    $.addrPtr get $.oldAddrPtr set

    {$.addrPtr get get} {$.newAddr get} {$.block get _mem_blockSize} mem_copyBytes
    $.addrPtr mem_free

    {$.newAddr get} {$.oldAddrPtr get} set
    1' ret

mem_setHeapBase: ( $addr -> )
    $_mem_heapBase set ret

mem_size: ( $addrPtr -> size )
    get
    dup 0 = ?{0 ret}
    _mem_Block~ - _mem_blockSize _mem_Block~ + ret

mem_copyBytes: ( $source $destination size -> )
    ${.destination: [0] .source: [0]}

    swap $.destination set
    swap $.source set

    .loop:
        dup 0 = ?{drop ret}

        {dup {$.source get} + get} {over {$.destination get} +} set

        --
        $.loop jump

mem_setDebugger: ( $callback( $message -> ) -> )
    $_mem_debugger set ret

new: mem_new ret
free: mem_free ret
resize: mem_resize ret